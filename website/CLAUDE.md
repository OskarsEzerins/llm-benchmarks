# Website CLAUDE.md

## Tech Stack

- **React 19** with **React Router 7** (file-based routing via `routes.ts`)
- **TypeScript 5.9** with strict typing
- **Tailwind CSS 4** for styling
- **Vite 6** as build tool
- **shadcn/ui** (new-york style) for UI components
- **Lucide React** for icons
- **pnpm** as package manager
- **Shiki** for syntax highlighting (Ruby code viewer)

## Available shadcn Components

Pre-installed: `card`, `badge`, `button`, `separator`, `progress`, `alert`, `navigation-menu`, `select`, `tabs`, `checkbox`, `dropdown-menu`

Add new components: `pnpm dlx shadcn@latest add <component>`

## Commands

```bash
pnpm dev          # Start dev server (runs aggregate_results first via predev hook)
pnpm build        # Production build (runs aggregate_results first via prebuild hook)
pnpm tsc          # Type check (runs typegen first)
# Data generation: ruby ../bin/aggregate_results website/public/data
# Note: model_names.json is written to website/app/data/ (not public/data/) so Vite
#       can import it as an ES module. All other generated files go to public/data/.
```

## Project Structure

```
website/
├── app/
│   ├── components/       # Reusable UI components
│   │   ├── ui/           # shadcn/ui primitives
│   │   └── *.tsx         # Custom components
│   ├── lib/              # Data loading, utilities
│   │   ├── data.ts       # Benchmark data loading & calculations
│   │   ├── implementations-data.ts  # Implementation manifest & source fetching
│   │   ├── model-names.ts           # Static model display name lookup (from config/model_names.json)
│   │   └── utils.ts      # cn() utility
│   ├── routes/           # Page components (React Router)
│   │   ├── home.tsx
│   │   ├── benchmarks.*.tsx
│   │   ├── implementations.tsx         # Browse page
│   │   ├── implementations.detail.tsx  # Single implementation view
│   │   └── implementations.compare.tsx # Side-by-side comparison
│   ├── types/
│   │   └── benchmark.ts  # TypeScript interfaces
│   └── routes.ts         # Route definitions
├── app/
│   └── data/             # Generated at build time, gitignored
│       └── model_names.json  # Copied from config/model_names.json for ES module import
├── public/data/          # Synced JSON data files (generated, gitignored)
│   ├── *.json            # Benchmark results
│   └── implementations.json  # Implementation manifest (with display_name per entry)
└── sync-data.sh          # Data sync script
```

## Data Loading Patterns

- **Server-side**: Use `fetch()` in route loaders (works on both server and client via URL construction)
- **Client-side**: Implementation source code fetched from local static files (`/data/implementations/`) on-demand
- Data generated by `ruby bin/aggregate_results website/public/data` (runs automatically via prebuild/predev hooks)
- `bin/aggregate_results` reads `config/model_names.json` (repo root) and bakes `display_name` into each entry in `implementations.json`

### Build-time vs. runtime file access

`bin/aggregate_results` runs at build time (before Vite) and writes generated data to two locations:

- `public/data/` — benchmark results and `implementations.json`, served as static URL-accessible files and fetched at runtime via `fetch()`
- `app/data/model_names.json` — copied here (not `public/data/`) so that Vite can process it as an ES module import. Vite forbids `import` statements targeting files inside `public/`, so this file must live in the app source tree.

The live server has no repo filesystem access; all data must be either statically imported (Vite inlines it) or served from `public/`.

## Routing Conventions

Routes defined in `app/routes.ts` using `route()` helper. Route files export:
- `meta()` - Page metadata
- `loader()` - Server-side data loading
- `default` component - Page component receiving `loaderData`

## Component Patterns

- Hooks-only functional components (no class components)
- Arrow function components with explicit typing
- Reuse `PageLayout`, `PageContent`, `HeroSection`, `Breadcrumbs` for page structure
- For display names: use `entry.display_name` when you have an `ImplementationEntry`; use `getDisplayName(slug)` from `lib/model-names.ts` when working with raw slugs (benchmark ranking data)

## Design Requirements

- **Mobile-first responsive design** - All features must work on 375px+ viewports
- Dark/light mode support via CSS variables and `dark:` variants
- Consistent use of shadcn/ui design tokens (`foreground`, `muted-foreground`, `primary`, etc.)
