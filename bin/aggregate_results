#!/usr/bin/env ruby
# frozen_string_literal: true

# Aggregates per-implementation result files into per-benchmark JSON files
# for the website. Run before building/serving the website.
#
# Usage: ruby bin/aggregate_results <output_dir>
# Example: ruby bin/aggregate_results website/public/data

require 'json'
require 'fileutils'

results_dir = File.expand_path('../results', __dir__)
output_dir  = File.expand_path(ARGV[0] || 'website/public/data', Dir.pwd)
FileUtils.mkdir_p(output_dir)

# Discover benchmark IDs and collect data from all per-implementation files
benchmark_results    = {}  # benchmark_id => { results: [], aggregates: {} }
benchmark_aggregates = {}

Dir.glob("#{results_dir}/*.json").each do |file|
  data = JSON.parse(File.read(file))
  implementation = data['implementation']
  next unless implementation

  data.each do |key, value|
    next if key == 'implementation'
    next unless value.is_a?(Hash) && value.key?('results')

    benchmark_id = key
    benchmark_results[benchmark_id]    ||= []
    benchmark_aggregates[benchmark_id] ||= {}

    benchmark_results[benchmark_id].concat(value['results'] || [])
    benchmark_aggregates[benchmark_id][implementation] = value['aggregate'] if value['aggregate']
  end
rescue JSON::ParserError
  next
end

benchmark_results.each_key do |benchmark_id|
  output = {
    'results'    => benchmark_results[benchmark_id],
    'aggregates' => benchmark_aggregates[benchmark_id]
  }
  output_file = File.join(output_dir, "#{benchmark_id}.json")
  File.write(output_file, JSON.pretty_generate(output))
  puts "Wrote #{output_file} (#{output['aggregates'].size} implementations)"
end

# Generate implementations manifest (metadata only, no source code)
implementations_dir = File.expand_path('../implementations', __dir__)
manifest_entries = []

# Load display name config
model_names_config = {}
config_file = File.expand_path('../config/model_names.json', __dir__)
if File.exist?(config_file)
  model_names_config = JSON.parse(File.read(config_file))
end

# Generic fallback formatter (title-case the slug stripped of date suffix)
def format_display_name(slug)
  base = slug
    .sub(/_openrouter_\d{2}_\d{4}$/, '')
    .sub(/_openai_api_\d{2}_\d{4}$/, '')
    .sub(/_cursor_chat_\d{2}_\d{4}$/, '')
    .sub(/_cursor_\d{2}_\d{4}$/, '')
    .sub(/_vscode_\d{2}_\d{4}$/, '')
    .sub(/_web_chat_\d{2}_\d{4}$/, '')
    .sub(/_web_\d{2}_\d{4}$/, '')
    .sub(/_\d{2}_\d{4}$/, '')
  base.split('_').map(&:capitalize).join(' ')
end

Dir.glob("#{implementations_dir}/**/*.rb").sort.each do |file|
  rel = file.sub("#{implementations_dir}/", '')
  parts = rel.split('/')
  next if parts.include?('broken') || parts.include?('slow')
  next unless parts.length == 3

  type  = parts[0]
  task  = parts[1]
  model = parts[2].sub(/\.rb$/, '')
  lines = File.read(file).count("\n")
  entry = model_names_config[model]
  display_name = entry.is_a?(Hash) ? entry['display_name'] : format_display_name(model)
  provider     = entry.is_a?(Hash) ? entry['provider']      : 'Other'
  manifest_entries << { type: type, task: task, model: model, lines: lines,
                        display_name: display_name, provider: provider }
rescue StandardError
  next
end

manifest_file = File.join(output_dir, 'implementations.json')
File.write(manifest_file, JSON.generate({ implementations: manifest_entries }))
puts "Wrote #{manifest_file} (#{manifest_entries.size} implementations)"

# Copy implementation source files for local static serving
copied_count = 0
Dir.glob("#{implementations_dir}/**/*.rb").sort.each do |file|
  rel   = file.sub("#{implementations_dir}/", '')
  parts = rel.split('/')
  next if parts.include?('broken') || parts.include?('slow')
  next unless parts.length == 3

  dest = File.join(output_dir, 'implementations', rel)
  FileUtils.mkdir_p(File.dirname(dest))
  FileUtils.cp(file, dest)
  copied_count += 1
rescue StandardError
  next
end
puts "Copied #{copied_count} implementation source files"

# Copy model_names.json into website/app/data/ so Vite can process it as a static ES module import.
# It must NOT go into public/ because Vite does not allow importing files from public/ via ES module syntax.
app_data_dir = File.expand_path('../website/app/data', __dir__)
FileUtils.mkdir_p(app_data_dir)
FileUtils.cp(config_file, File.join(app_data_dir, 'model_names.json'))
puts "Copied model_names.json to #{app_data_dir}/"

puts "Done. Output written to #{output_dir}/"
