#!/usr/bin/env ruby
# frozen_string_literal: true

# Aggregates per-implementation result files into per-benchmark JSON files
# for the website. Run before building/serving the website.
#
# Usage: ruby bin/aggregate_results <output_dir>
# Example: ruby bin/aggregate_results website/public/data

require 'json'
require 'fileutils'

results_dir = File.expand_path('../results', __dir__)
output_dir  = File.expand_path(ARGV[0] || 'website/public/data', Dir.pwd)
FileUtils.mkdir_p(output_dir)

# Discover benchmark IDs and collect data from all per-implementation files
benchmark_results    = {}  # benchmark_id => { results: [], aggregates: {} }
benchmark_aggregates = {}

Dir.glob("#{results_dir}/*.json").each do |file|
  data = JSON.parse(File.read(file))
  implementation = data['implementation']
  next unless implementation

  data.each do |key, value|
    next if key == 'implementation'
    next unless value.is_a?(Hash) && value.key?('results')

    benchmark_id = key
    benchmark_results[benchmark_id]    ||= []
    benchmark_aggregates[benchmark_id] ||= {}

    benchmark_results[benchmark_id].concat(value['results'] || [])
    benchmark_aggregates[benchmark_id][implementation] = value['aggregate'] if value['aggregate']
  end
rescue JSON::ParserError
  next
end

benchmark_results.each_key do |benchmark_id|
  output = {
    'results'    => benchmark_results[benchmark_id],
    'aggregates' => benchmark_aggregates[benchmark_id]
  }
  output_file = File.join(output_dir, "#{benchmark_id}.json")
  File.write(output_file, JSON.pretty_generate(output))
  puts "Wrote #{output_file} (#{output['aggregates'].size} implementations)"
end

# Generate implementations manifest (metadata only, no source code)
implementations_dir = File.expand_path('../implementations', __dir__)
manifest_entries = []

Dir.glob("#{implementations_dir}/**/*.rb").sort.each do |file|
  rel = file.sub("#{implementations_dir}/", '')
  parts = rel.split('/')
  next if parts.include?('broken') || parts.include?('slow')
  next unless parts.length == 3

  type  = parts[0]
  task  = parts[1]
  model = parts[2].sub(/\.rb$/, '')
  lines = File.read(file).count("\n")
  manifest_entries << { type: type, task: task, model: model, lines: lines }
rescue StandardError
  next
end

manifest_file = File.join(output_dir, 'implementations.json')
File.write(manifest_file, JSON.generate({ implementations: manifest_entries }))
puts "Wrote #{manifest_file} (#{manifest_entries.size} implementations)"

# Copy implementation source files for local static serving
copied_count = 0
Dir.glob("#{implementations_dir}/**/*.rb").sort.each do |file|
  rel   = file.sub("#{implementations_dir}/", '')
  parts = rel.split('/')
  next if parts.include?('broken') || parts.include?('slow')
  next unless parts.length == 3

  dest = File.join(output_dir, 'implementations', rel)
  FileUtils.mkdir_p(File.dirname(dest))
  FileUtils.cp(file, dest)
  copied_count += 1
rescue StandardError
  next
end
puts "Copied #{copied_count} implementation source files"

puts "Done. Output written to #{output_dir}/"
